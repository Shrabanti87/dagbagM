######################
#####update on 09-18-2011 by jie; two functions: 1. gene.pancr and 2. gene.pancr.label
######################


######################
gene.pancr.tdist<-function(N, pancr.adj, df, bmin=0.3, bmax=0.5, SN=runif(nrow(pancr.adj), min=0.5, max=1.5),flip=FALSE)
{
###shape=a, scale=s corresponding to the parameters in rgamma in R
### originally written by Pei. need to order the nodes such that parents nodes always have smaller indices than children nodes 
#### also the DAG can only has one root which is node 1
### pancr.adj[i,j] indicates the existence of edge i--->j
### generate data based on a Gaussian linear mechnism and a DAG 
### para: N -- sample size, pancr.adj: adjacency matrix, bmin -- lower bound for the coefficients, bmax -- upper bound for the coefficients 
### SN: a p-vector , signal to noise ratio, used to determine the variance of the residuals 
### return: N by p data matrix 

  size=nrow(pancr.adj)   ##number of nodes 

  beta.simu=matrix(0, nrow=size, ncol=size)
  beta.simu[pancr.adj==1]=runif(sum(pancr.adj), min=bmin, max=bmax)  ##coefficients for linear mechanism 

  if(flip==TRUE){
    sign.temp=numeric(sum(pancr.adj==1))
    sign.temp=sample(c(-1,1),length(sign.temp),replace=TRUE)
    beta.simu[pancr.adj==1]=beta.simu[pancr.adj==1]*sign.temp
  }
  result=matrix(0, N, size)   ##data matrix 
  result[,1]=rt(N, df=df)  ##node one is the root, generate the root node 
  result[,1]=result[,1]/sqrt(df/(df-2)) ##mean=0, sd=1

  esd.v=rep(0, size)    ##sd for the residuals in the linear mechanism 
  esd.v[1]=1
  
  
  for(i in 2:size)
   {
      temp=beta.simu[,i]    ## 1:(i-1): parents coefficients for the ith node  
      if(i==2)
      {
        yhat=result[,1:(i-1)]*temp[1:(i-1)]
      } else {
         yhat=result[,1:(i-1)]%*%as.matrix(temp[1:(i-1)])
       }  
      ysd=sd(yhat)
      esd.v[i]=ysd/SN[i]    ## sd for the residual in the ith linear mechanism, set such that the ith SNR is SN[i]
      error=rt(N, df=df)
      error=error*esd.v[i]/sqrt(df/(df-2))
      result[,i]=yhat+error
   }
   return(list(data=result, beta=beta.simu, esd=esd.v))
}


#######################
gene.pancr.label.tdist<-function(N, pancr.adj, df, bmin=0.3, bmax=0.5, SN=runif(nrow(pancr.adj), min=0.5, max=1.5),flip=FALSE)
{
### originally written by Ru on 09-16-2011: to generate a more general Gaussian linear mechanism
### applicable to any DAG 
### pancr.adj[i,j] indicates the existence of edge i--->j
### para: N -- sample size, pancr.adj: adjacency matrix, bmin -- lower bound for the coefficients, bmax -- upper bound for the coefficients 
### SN: a p-vector , signal to noise ratio, used to determine the variance of the residuals 
### return: N by p data matrix 

  size=nrow(pancr.adj)

  beta.simu=matrix(0, nrow=size, ncol=size)
  beta.simu[pancr.adj==1]=runif(sum(pancr.adj), min=bmin, max=bmax)
  if(flip==TRUE){
    sign.temp=numeric(sum(pancr.adj==1))
    sign.temp=sample(c(-1,1),length(sign.temp),replace=TRUE)
    beta.simu[pancr.adj==1]=beta.simu[pancr.adj==1]*sign.temp
  }

  result=matrix(0, N, size)
  
  tt=which(colSums(pancr.adj)==0)  ### find out nodes without parents 
  for(j in tt){
    result[,j]=rt(N, df=df)  ### generate them from gamma(shape,scale)
    result[,j]=result[,j]/sqrt(df/(df-2)) ##mean=0, sd=1
  }

  esd.v=rep(0, size)
  esd.v[tt]=1

  tt2=(1:size)[-tt]   ##nodes with at least one parents 
  current=tt2

  while(length(current)>0){

      i=current[1]                      ##look at node i  
      temp=beta.simu[,i]
      temp2=which(temp!=0)     ##parents for node i
      check=numeric(length(temp2))

      for(m in 1:length(temp2)){
        check[m]=all(result[,temp2[m]]==0)   ##check whether node i's parents have been generated: check =0 yes, check =1, not yet 
      }

      if(any(check!=0)){  ##if some parents of node i have not been generated 
        current=current[-1]
        current=c(current,i)
      }

      if(all(check==0)){  ## if all parenets of node i have been generated 
      
         yhat=as.matrix(result[,temp2],nrow=N)%*%as.matrix(temp[temp2])
         ysd=sd(yhat)
         esd.v[i]=ysd/SN[i]
         error=rt(N, df=df)
         error=error*esd.v[i]/sqrt(df/(df-2))
         result[,i]=yhat+error
         current=current[-1]
      } 

   }##end while 

   return(list(data=result, beta=beta.simu, esd=esd.v))
}


